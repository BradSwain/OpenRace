(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{79:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return r})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return d}));var a=n(3),s=n(7),l=(n(0),n(88)),i={id:"doc-overview",title:"Design Overview"},r={unversionedId:"doc-overview",id:"doc-overview",isDocsHomePage:!1,title:"Design Overview",description:"High Level Design",source:"@site/docs/doc-overview.md",slug:"/doc-overview",permalink:"/OpenRace/doc-overview",editUrl:"https://github.com/coderrect-inc/OpenRace/edit/master/website/docs/doc-overview.md",version:"current",sidebar:"someSidebar",previous:{title:"Style Guide",permalink:"/OpenRace/"},next:{title:"How to Contribute?",permalink:"/OpenRace/doc-contributing"}},c=[{value:"High Level Design",id:"high-level-design",children:[{value:"Phase I: Converting LLVM IR to RaceIR",id:"phase-i-converting-llvm-ir-to-raceir",children:[]},{value:"Phase II: Converting RaceIR to a Trace of Events",id:"phase-ii-converting-raceir-to-a-trace-of-events",children:[]},{value:"Phase III: Analysis",id:"phase-iii-analysis",children:[]}]}],o={toc:c};function d(e){var t=e.components,n=Object(s.a)(e,["components"]);return Object(l.b)("wrapper",Object(a.a)({},o,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h2",{id:"high-level-design"},"High Level Design"),Object(l.b)("p",null,"The high level design is split into three phases."),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},'Convert LLVM IR to "RaceIR" (need a better name)'),Object(l.b)("li",{parentName:"ol"},'Convert "RaceIR" to a trace of events'),Object(l.b)("li",{parentName:"ol"},"Run analyses on the program trace")),Object(l.b)("p",null,"TODO: image here"),Object(l.b)("h3",{id:"phase-i-converting-llvm-ir-to-raceir"},"Phase I: Converting LLVM IR to RaceIR"),Object(l.b)("p",null,"The RaceIR acts as a high level interface tp wrap LLVM IR."),Object(l.b)("p",null,"For example, there are lots of llvm instructions we would like to treat as logical reads."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"    %a = load %val\n    %b = call @memcopy(...)\n    %c = call @vector_bracket_operator(...)\n")),Object(l.b)("p",null,"RaceIR defines an interface for the logical operations we care about (read/write/fork/join/etc.), without dealing with\nthe underlying llvm instructions directly."),Object(l.b)("p",null,"The RaceIR interface for read might look something like:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"class Read {\npublic:\n    virtual const llvm::Inst* getInst() const =  0;\n    virtual const llvm::Value *getReadValue() const = 0;\n};\n")),Object(l.b)("p",null,"Now to treat different types of llvm instructions as reads, we just need to define a derived class implementing the read\ninterface."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"class Load : public Read {\n    const LoadInst *load;\npublic:\n    const llvm::LoadInst* getInst() const override { return load; }\n    const llvm::Value *getReadValue() const override { return load->getPointerOperand(); }\n};\n\nclass MemCpyRead : public Read {\n    const CallBase *inst;\npublic:\n    const llvm::LoaCallBasedInst* getInst() const override { return inst; }\n\n    // Assuming 3rd operand is the value being read. This is a fake example\n    const llvm::Value *getReadValue() const override { return load->getOperand(3); }\n};\n")),Object(l.b)("p",null,"The same interface defined for all the logical operations we care about. This way later phases can directly access the\ninfo they care about (e.g. what memory is being read) without having to deal with udnerlying llvm instructions directly."),Object(l.b)("p",null,'The actual work done in the first phase is converting LLVM IR to "RaceIR".'),Object(l.b)("p",null,'For this there is an InfoBuilder class that takes an LLVM IR Function and returns RaceIRFunction containing only the\nrelevant wrapped "RaceIR" instructions.'),Object(l.b)("p",null,"// TODO: Put image here from my presentation"),Object(l.b)("h3",{id:"phase-ii-converting-raceir-to-a-trace-of-events"},"Phase II: Converting RaceIR to a Trace of Events"),Object(l.b)("p",null,"This phase simulates execution of the RaceIR (and by proxy llvm IR) across multiple threads and generates a static trace\nof events."),Object(l.b)("p",null,"Events in the trace represent actual events being executed in a program."),Object(l.b)("p",null,'"RaceIR" classes answer questions in terms of llvm IR. TraceEvents answer questions in terms of (static) execution.'),Object(l.b)("p",null,'While the read interface in "RaceIR" has a function that tells us what llvm value is being accessed, a read event will\nhave a function telling us what logical memory is being accessed.'),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"class Read {\n    const llvm::Value *getAccessedValue() const;\n};\n\nclass ReadEvent {\n    std::vector<AbstractObj> getAccessedMemory() const;\n};\n")),Object(l.b)("p",null,"Internally, events are essentially bundling RaceIR and pointer analysis (PTA) info together, and traces are constructed\nby traversing the callgraph generated by PTA."),Object(l.b)("p",null,'The main purpose of a seperate "Trace" phase and class is to hide the details of PTA from later phases.'),Object(l.b)("h3",{id:"phase-iii-analysis"},"Phase III: Analysis"),Object(l.b)("p",null,"Once a trace has been generated, analyses can be run on that trace by examining events and querying their APIs."),Object(l.b)("p",null,"The three main analyses we care about for race detection are:"),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"SharedMemory - find shared accesses across threads"),Object(l.b)("li",{parentName:"ol"},"HappensBefore - find events executed in parallel"),Object(l.b)("li",{parentName:"ol"},"Lockset - find out what locks an event holds")),Object(l.b)("h4",{id:"sharedmemory-analysis"},"SharedMemory Analysis"),Object(l.b)("p",null,"TODO"),Object(l.b)("h4",{id:"happensbefore-analysis"},"HappensBefore Analysis"),Object(l.b)("p",null,"TODO"),Object(l.b)("h4",{id:"lockset-analysis"},"Lockset Analysis"),Object(l.b)("p",null,"TODO"))}d.isMDXComponent=!0}}]);